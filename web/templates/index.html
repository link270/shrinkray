<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Shrinkray</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="icon" type="image/png" href="/favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #FAFAFA;
            --bg-secondary: #FFFFFF;
            --bg-tertiary: #F5F5F5;
            --text-primary: #1A1A1A;
            --text-secondary: #6B6B6B;
            --text-tertiary: #9A9A9A;
            --accent: #2563EB;
            --accent-hover: #1D4ED8;
            --accent-light: #EFF6FF;
            --success: #059669;
            --success-light: #ECFDF5;
            --warning: #D97706;
            --warning-light: #FFFBEB;
            --error: #DC2626;
            --error-light: #FEF2F2;
            --border: #E5E5E5;
            --border-hover: #D4D4D4;
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.04);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
            --shadow-lg: 0 12px 32px rgba(0,0,0,0.12);
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 24px;
            --font-sans: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
            --transition-fast: 150ms ease;
            --transition-normal: 250ms ease;
        }

        [data-theme="dark"] {
            --bg-primary: #0F0F0F;
            --bg-secondary: #1A1A1A;
            --bg-tertiary: #252525;
            --text-primary: #F5F5F5;
            --text-secondary: #A0A0A0;
            --text-tertiary: #6B6B6B;
            --accent: #3B82F6;
            --accent-hover: #60A5FA;
            --accent-light: #1E3A5F;
            --success: #10B981;
            --success-light: #064E3B;
            --warning: #F59E0B;
            --warning-light: #78350F;
            --error: #EF4444;
            --error-light: #7F1D1D;
            --border: #2D2D2D;
            --border-hover: #404040;
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.2);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.3);
            --shadow-lg: 0 12px 32px rgba(0,0,0,0.4);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--font-sans);
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
        }

        /* Layout */
        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
        }

        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 0 24px;
            height: 64px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 1.125rem;
            letter-spacing: -0.02em;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            border-radius: var(--radius-sm);
            overflow: hidden;
        }

        .logo-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .stats-bar {
            display: flex;
            gap: 24px;
            margin-left: 40px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-value {
            font-weight: 600;
            font-size: 0.9375rem;
            font-variant-numeric: tabular-nums;
        }

        .stat-label {
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }

        .stat-item.success .stat-value { color: var(--success); }
        .stat-item.running .stat-value { color: var(--accent); }

        /* Saved stat dropdown */
        .stat-saved-wrapper {
            position: relative;
        }

        .stat-saved-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 4px 0;
            margin: -4px 0;
            border-radius: var(--radius-sm);
            transition: opacity var(--transition-fast);
        }

        .stat-saved-toggle:hover {
            opacity: 0.8;
        }

        .stat-saved-chevron {
            width: 14px;
            height: 14px;
            color: var(--text-tertiary);
            transition: transform var(--transition-fast);
            flex-shrink: 0;
        }

        .stat-saved-wrapper.open .stat-saved-chevron {
            transform: rotate(180deg);
        }

        .stat-saved-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%) translateY(-4px);
            opacity: 0;
            visibility: hidden;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            box-shadow: var(--shadow-md);
            padding: 12px 16px;
            min-width: 180px;
            z-index: 200;
            transition: opacity var(--transition-fast), transform var(--transition-fast), visibility var(--transition-fast);
        }

        .stat-saved-wrapper.open .stat-saved-dropdown {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        .stat-saved-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
        }

        .stat-saved-row:not(:last-child) {
            border-bottom: 1px solid var(--border);
        }

        .stat-saved-row-label {
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }

        .stat-saved-row-value {
            font-size: 0.9375rem;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .stat-saved-row-value.lifetime {
            color: var(--success);
        }

        .stat-saved-reset {
            width: 100%;
            margin-top: 4px;
            padding: 8px 12px;
            font-size: 0.8125rem;
            font-family: var(--font-sans);
            font-weight: 500;
            color: var(--text-secondary);
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .stat-saved-reset:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
            border-color: var(--border-hover);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .menu-btn {
            width: 40px;
            height: 40px;
            border: none;
            background: transparent;
            border-radius: var(--radius-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            transition: all var(--transition-fast);
        }

        .menu-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .menu-btn svg {
            width: 20px;
            height: 20px;
        }

        /* Theme toggle icons */
        .theme-icon-light { display: none; }
        .theme-icon-dark { display: block; }
        [data-theme="dark"] .theme-icon-light { display: block; }
        [data-theme="dark"] .theme-icon-dark { display: none; }

        .main {
            flex: 1;
            display: flex;
            align-items: flex-start;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
            padding: 24px;
            gap: 24px;
            min-height: 0;
            overflow: hidden;
        }

        /* Browser Panel */
        .browser-panel {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .panel {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border);
            overflow: hidden;
        }

        /* File browser panel - sizes to content */
        .browser-panel > .panel {
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 112px);
        }

        .panel-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .panel-title {
            font-weight: 600;
            font-size: 0.9375rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.875rem;
            color: var(--text-secondary);
            padding: 12px 20px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            overflow: hidden;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .breadcrumb a {
            color: var(--accent);
            text-decoration: none;
            transition: color var(--transition-fast);
        }

        .breadcrumb a:hover {
            color: var(--accent-hover);
        }

        .breadcrumb-sep {
            color: var(--text-tertiary);
            margin: 0 4px;
        }

        .breadcrumb-current {
            color: var(--text-primary);
            font-weight: 500;
        }

        .breadcrumb-collapsed {
            color: var(--text-tertiary);
        }

        .file-list {
            list-style: none;
            overflow-y: auto;
        }

        .file-list-header {
            display: flex;
            align-items: center;
            padding: 10px 20px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            font-size: 0.8125rem;
            color: var(--text-secondary);
            gap: 12px;
            flex-shrink: 0;
        }

        .file-list-header label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
        }

        .file-item {
            display: flex;
            align-items: center;
            padding: 12px 20px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background var(--transition-fast);
            gap: 12px;
        }

        .file-item:hover {
            background: var(--bg-tertiary);
        }

        .file-item:last-child {
            border-bottom: none;
        }

        .file-item.selected {
            background: var(--accent-light);
        }

        .file-item.selected:hover {
            background: #DBEAFE;
        }

        .file-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--accent);
            flex-shrink: 0;
        }

        .file-icon {
            width: 36px;
            height: 36px;
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-size: 1rem;
        }

        .file-icon.folder {
            background: #FEF3C7;
            color: #D97706;
        }

        .file-icon.video {
            background: var(--accent-light);
            color: var(--accent);
        }

        .file-icon.other {
            background: var(--bg-tertiary);
            color: var(--text-tertiary);
        }

        .file-info {
            flex: 1;
            min-width: 0;
        }

        .file-name {
            font-weight: 500;
            font-size: 0.9375rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-meta {
            font-size: 0.8125rem;
            color: var(--text-secondary);
            margin-top: 2px;
            display: flex;
            gap: 12px;
        }

        .file-size {
            font-variant-numeric: tabular-nums;
            color: var(--text-tertiary);
            font-size: 0.8125rem;
            flex-shrink: 0;
        }

        .codec-badge {
            display: inline-flex;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }

        .codec-badge.hevc,
        .codec-badge.av1 {
            background: var(--success-light);
            color: var(--success);
        }

        .codec-badge.h264 {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }

        .file-list-empty {
            padding: 60px 20px;
            text-align: center;
            color: var(--text-secondary);
        }

        /* Actions Bar */
        .actions-bar {
            display: flex;
            gap: 12px;
            padding: 16px 20px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border);
            align-items: center;
            flex-shrink: 0;
        }

        .preset-select {
            padding: 10px 14px;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            font-family: var(--font-sans);
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            min-width: 200px;
            transition: border-color var(--transition-fast);
        }

        .preset-select:hover {
            border-color: var(--border-hover);
        }

        .preset-select:focus {
            outline: none;
            border-color: var(--accent);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 18px;
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            font-weight: 500;
            font-family: var(--font-sans);
            cursor: pointer;
            border: none;
            transition: all var(--transition-fast);
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .btn-primary:disabled {
            background: var(--border);
            cursor: not-allowed;
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--bg-tertiary);
            border-color: var(--border-hover);
        }

        .btn-secondary:disabled {
            opacity: 0.4;
            cursor: default;
        }

        .btn-danger {
            background: var(--error);
            color: white;
        }

        .btn-danger:hover {
            background: #B91C1C;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 0.8125rem;
        }

        .selection-count {
            margin-left: auto;
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }

        .schedule-status {
            font-size: 0.8125rem;
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .schedule-status svg {
            width: 14px;
            height: 14px;
        }

        /* Queue Filter */
        .queue-filter {
            padding: 4px 8px;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            font-family: var(--font-sans);
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            margin-left: auto;
        }

        .queue-filter:hover {
            border-color: var(--border-hover);
        }

        .queue-filter:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* Queue Panel */
        .queue-panel {
            width: 400px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 16px;
            max-height: calc(100vh - 112px); /* viewport - header - padding */
        }

        .queue-panel-inner {
            display: flex;
            flex-direction: column;
            max-height: 100%;
        }

        .queue-list {
            overflow-y: auto;
        }

        .job-item {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
        }

        .job-item:last-child {
            border-bottom: none;
        }

        .job-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 8px;
        }

        .job-name {
            font-weight: 500;
            font-size: 0.9375rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            min-width: 0;
        }

        .job-badges {
            display: flex;
            gap: 6px;
            flex-shrink: 0;
        }

        .job-badge {
            display: inline-flex;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }

        .job-badge.pending {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }

        .job-badge.running {
            background: var(--accent-light);
            color: var(--accent);
        }

        .job-badge.complete {
            background: var(--success-light);
            color: var(--success);
        }

        .job-badge.failed {
            background: var(--error-light);
            color: var(--error);
        }

        .job-badge.initializing {
            background: #F3E8FF;
            color: #7C3AED;
        }

        .job-badge.hardware {
            background: var(--success-light);
            color: var(--success);
        }

        .job-badge.software {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }

        .job-progress {
            margin: 12px 0;
        }

        .progress-bar {
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 3px;
            transition: width var(--transition-normal);
        }

        .progress-fill.initializing {
            background: linear-gradient(90deg, #DDD6FE 0%, #A78BFA 50%, #DDD6FE 100%);
            background-size: 200% 100%;
            animation: shimmer 2s ease-in-out infinite;
        }

        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .job-details {
            display: flex;
            gap: 16px;
            font-size: 0.8125rem;
            color: var(--text-secondary);
            margin-top: 8px;
        }

        .job-detail {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .job-detail-value {
            font-weight: 500;
            font-variant-numeric: tabular-nums;
        }

        .job-saved {
            color: var(--success);
        }

        .job-error {
            color: var(--error);
            font-size: 0.8125rem;
            margin-top: 8px;
        }

        .job-actions {
            margin-top: 12px;
        }

        .queue-empty {
            padding: 24px 20px;
            text-align: center;
            color: var(--text-secondary);
        }

        .queue-empty-icon {
            font-size: 2rem;
            margin-bottom: 8px;
            opacity: 0.5;
        }

        /* Processing Banner */
        .processing-banner {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px 20px;
            background: var(--accent-light);
            border-bottom: 1px solid var(--border);
            color: var(--accent);
            font-weight: 500;
            font-size: 0.875rem;
        }
        .processing-banner.hidden { display: none; }
        .processing-spinner {
            width: 18px;
            height: 18px;
            border: 2px solid var(--accent);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            flex-shrink: 0;
        }

        .queue-footer {
            padding: 12px 20px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex-shrink: 0;
        }

        .queue-footer-buttons {
            display: flex;
            gap: 8px;
        }

        .queue-error:empty {
            display: none;
        }

        .queue-error {
            color: var(--error);
            font-size: 0.75rem;
            text-align: center;
        }

        .notify-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8125rem;
            color: var(--text-secondary);
            cursor: pointer;
            user-select: none;
        }

        .notify-label input {
            accent-color: var(--accent);
            cursor: pointer;
        }

        /* Settings Menu */
        .settings-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 200;
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-normal);
        }

        .settings-overlay.open {
            opacity: 1;
            visibility: visible;
        }

        .settings-panel {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 400px;
            max-width: 100%;
            background: var(--bg-secondary);
            z-index: 201;
            transform: translateX(100%);
            transition: transform var(--transition-normal);
            display: flex;
            flex-direction: column;
        }

        .settings-overlay.open .settings-panel {
            transform: translateX(0);
        }

        .settings-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .settings-title {
            font-weight: 600;
            font-size: 1.125rem;
        }

        .settings-close {
            width: 36px;
            height: 36px;
            border: none;
            background: transparent;
            border-radius: var(--radius-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            transition: all var(--transition-fast);
        }

        .settings-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }

        .setting-group {
            margin-bottom: 32px;
        }

        .setting-group:last-child {
            margin-bottom: 0;
        }

        .setting-group-title {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-tertiary);
            margin-bottom: 16px;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid var(--border);
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .setting-info {
            flex: 1;
        }

        .setting-name {
            font-weight: 500;
            font-size: 0.9375rem;
            margin-bottom: 2px;
        }

        .setting-desc {
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }

        .setting-control {
            margin-left: 16px;
        }

        .setting-select {
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            font-family: var(--font-sans);
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            min-width: 160px;
        }

        .setting-input {
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            font-family: var(--font-sans);
            background: var(--bg-secondary);
            color: var(--text-primary);
            width: 200px;
        }

        .setting-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .setting-input::placeholder {
            color: var(--text-tertiary);
        }

        .setting-warning {
            font-size: 0.8125rem;
            color: #b45309;
            padding: 0 0 8px 0;
        }

        .setting-group-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 4px 0;
        }

        .setting-group-header:hover .setting-group-title {
            color: var(--text-primary);
        }

        .setting-group-toggle {
            width: 20px;
            height: 20px;
            color: var(--text-tertiary);
            transition: transform 0.2s ease;
        }

        .setting-group.collapsed .setting-group-toggle {
            transform: rotate(-90deg);
        }

        .setting-group-content {
            overflow: hidden;
            transition: max-height 0.2s ease;
            max-height: 500px;
        }

        .setting-group.collapsed .setting-group-content {
            max-height: 0;
        }

        .setting-item-stacked {
            flex-direction: column;
            align-items: stretch;
        }

        .setting-item-stacked .setting-control {
            margin-left: 0;
            margin-top: 12px;
        }

        .quality-slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
            width: 100%;
        }

        .quality-label {
            font-size: 0.75rem;
            color: var(--text-tertiary);
            white-space: nowrap;
        }

        .quality-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--border);
            border-radius: 3px;
            outline: none;
        }

        .quality-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .quality-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .quality-input {
            width: 60px;
            padding: 6px 8px;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            font-family: var(--font-sans);
            background: var(--bg-secondary);
            color: var(--text-primary);
            text-align: center;
        }

        .quality-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* Hide spinner buttons on number input */
        .quality-input::-webkit-outer-spin-button,
        .quality-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .quality-input[type=number] {
            -moz-appearance: textfield;
        }

        .settings-status {
            padding: 12px 24px;
            font-size: 0.8125rem;
            color: var(--success);
            min-height: 44px;
            display: flex;
            align-items: center;
        }

        .settings-status.error {
            color: var(--error);
        }

        .settings-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--border);
            font-size: 12px;
            color: var(--text-tertiary);
            text-align: center;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .main {
                flex-direction: column;
                overflow-y: auto;
                align-items: stretch;
            }

            .browser-panel {
                flex: none;
            }

            .file-list {
                max-height: 50vh;
            }

            .queue-panel {
                width: 100%;
                position: static;
                align-self: stretch;
                max-height: none;
            }

            .queue-panel-inner {
                max-height: none;
            }

            .queue-list {
                max-height: 300px;
            }
        }

        @media (max-width: 768px) {
            .header {
                padding: 0 16px;
            }

            .stats-bar {
                gap: 12px;
                margin-left: 16px;
            }

            .stat-label {
                display: none;
            }

            .stat-value {
                font-size: 0.8125rem;
            }

            .main {
                padding: 16px;
                gap: 16px;
            }

            .settings-panel {
                width: 100%;
            }

            .actions-bar {
                flex-wrap: wrap;
            }

            .preset-select {
                width: 100%;
                min-width: 0;
            }
        }

        /* Loading State */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 12px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Hidden utility */
        .hidden {
            display: none !important;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-normal), visibility var(--transition-normal);
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            max-width: 420px;
            width: calc(100% - 32px);
            padding: 24px;
            transform: scale(0.95) translateY(10px);
            transition: transform var(--transition-normal);
        }

        .modal-overlay.active .modal {
            transform: scale(1) translateY(0);
        }

        .modal-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 12px;
        }

        .modal-message {
            font-size: 0.9375rem;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 24px;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-actions .btn {
            min-width: 100px;
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <div class="header-left">
                <div class="logo">
                    <div class="logo-icon">
                        <img src="/logo.png" alt="Shrinkray" width="32" height="32">
                    </div>
                    Shrinkray
                </div>
                <div class="stats-bar" id="stats-bar">
                    <div class="stat-item running">
                        <span class="stat-value" id="stat-running">0</span>
                        <span class="stat-label">running</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="stat-pending">0</span>
                        <span class="stat-label">pending</span>
                    </div>
                    <div class="stat-item success stat-saved-wrapper" id="stat-saved-wrapper">
                        <div class="stat-saved-toggle" onclick="toggleSavedDropdown(event)">
                            <span class="stat-value" id="stat-saved">0 MB</span>
                            <span class="stat-label">saved</span>
                            <svg class="stat-saved-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="6 9 12 15 18 9"/>
                            </svg>
                        </div>
                        <div class="stat-saved-dropdown">
                            <div class="stat-saved-row">
                                <span class="stat-saved-row-label">Session</span>
                                <span class="stat-saved-row-value" id="stat-session-saved">0 MB</span>
                            </div>
                            <div class="stat-saved-row">
                                <span class="stat-saved-row-label">Lifetime</span>
                                <span class="stat-saved-row-value lifetime" id="stat-lifetime-saved">0 MB</span>
                            </div>
                            <div class="stat-saved-row" style="border: none; padding-top: 8px;">
                                <button class="stat-saved-reset" onclick="resetSession(event)">Reset Session</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="header-right">
                <button class="menu-btn" onclick="toggleTheme()" title="Toggle dark mode" id="theme-toggle">
                    <svg class="theme-icon-light" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"/>
                        <line x1="12" y1="1" x2="12" y2="3"/>
                        <line x1="12" y1="21" x2="12" y2="23"/>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                        <line x1="1" y1="12" x2="3" y2="12"/>
                        <line x1="21" y1="12" x2="23" y2="12"/>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                    </svg>
                    <svg class="theme-icon-dark" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                </button>
                <button class="menu-btn" onclick="openSettings()" title="Settings">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"/>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                    </svg>
                </button>
            </div>
        </header>

        <main class="main">
            <div class="browser-panel">
                <div class="panel">
                    <div class="breadcrumb" id="breadcrumb">
                        <div class="loading">
                            <div class="spinner"></div>
                            Loading...
                        </div>
                    </div>
                    <div class="file-list-header hidden" id="file-list-header">
                        <label>
                            <input type="checkbox" class="file-checkbox" id="select-all-checkbox" onchange="toggleSelectAll(this)">
                            Select all
                        </label>
                        <span id="selection-count"></span>
                    </div>
                    <ul class="file-list" id="file-list">
                        <li class="loading">
                            <div class="spinner"></div>
                            Loading files...
                        </li>
                    </ul>
                    <div class="actions-bar">
                        <select class="preset-select" id="preset-select" onchange="onPresetChange()">
                            <option value="compress-hevc">Compress (HEVC)</option>
                        </select>
                        <button class="btn btn-primary" onclick="startJobs()" id="start-btn" disabled>Start Transcode</button>
                        <span class="selection-count" id="selection-summary"></span>
                        <span class="schedule-status" id="schedule-status"></span>
                    </div>
                </div>
            </div>

            <div class="queue-panel">
                <div class="panel queue-panel-inner">
                    <div class="panel-header">
                        <span class="panel-title">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="8" y1="6" x2="21" y2="6"/>
                                <line x1="8" y1="12" x2="21" y2="12"/>
                                <line x1="8" y1="18" x2="21" y2="18"/>
                                <line x1="3" y1="6" x2="3.01" y2="6"/>
                                <line x1="3" y1="12" x2="3.01" y2="12"/>
                                <line x1="3" y1="18" x2="3.01" y2="18"/>
                            </svg>
                            Queue
                        </span>
                        <select class="queue-filter" id="queue-filter" onchange="setQueueFilter(this.value)">
                            <option value="all">All</option>
                            <option value="running">Running</option>
                            <option value="pending">Pending</option>
                            <option value="failed">Failed</option>
                            <option value="complete">Complete</option>
                            <option value="cancelled">Cancelled</option>
                        </select>
                        <label class="notify-label" id="notify-container" style="display: none">
                            <input type="checkbox" id="notify-checkbox" onchange="updateNotifySetting(this.checked)">
                            <span>Notify when done</span>
                        </label>
                    </div>
                    <div id="processing-banner" class="processing-banner hidden">
                        <div class="processing-spinner"></div>
                        <span id="processing-text">Processing files...</span>
                    </div>
                    <div class="queue-list" id="queue-list">
                        <div class="queue-empty">
                            <div class="queue-empty-icon">
                                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.3">
                                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                                    <path d="M3 9h18"/>
                                    <path d="M9 21V9"/>
                                </svg>
                            </div>
                            <div>No jobs in queue</div>
                            <div style="font-size: 0.8125rem; margin-top: 4px; color: var(--text-tertiary)">Select files and start transcoding</div>
                        </div>
                    </div>
                    <div class="queue-footer">
                        <div class="queue-footer-buttons">
                            <button class="btn btn-secondary btn-sm" id="stop-resume-btn" onclick="toggleStopResume()" style="flex: 1">Stop All</button>
                            <button class="btn btn-secondary btn-sm" id="clear-btn" onclick="clearQueue()" style="flex: 1">Clear</button>
                        </div>
                        <div id="queue-error" class="queue-error"></div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Settings Panel -->
    <div class="settings-overlay" id="settings-overlay" onclick="closeSettings(event)">
        <div class="settings-panel" onclick="event.stopPropagation()">
            <div class="settings-header">
                <span class="settings-title">Settings</span>
                <button class="settings-close" onclick="closeSettings()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>
            <div class="settings-content">
                <div class="setting-group">
                    <div class="setting-group-title">Transcoding</div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">Original files</div>
                            <div class="setting-desc">What happens after transcoding</div>
                        </div>
                        <div class="setting-control">
                            <select class="setting-select" id="setting-original-handling" onchange="updateSetting('original_handling', this.value)">
                                <option value="replace">Delete original</option>
                                <option value="keep">Keep as .old</option>
                            </select>
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">Concurrent jobs</div>
                            <div class="setting-desc">Simultaneous transcode tasks</div>
                        </div>
                        <div class="setting-control">
                            <select class="setting-select" id="setting-workers" onchange="updateSetting('workers', parseInt(this.value))">
                                <option value="1">1</option>
                                <option value="2">2 (recommended)</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                                <option value="5">5</option>
                                <option value="6">6</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="setting-group">
                    <div class="setting-group-title">Schedule</div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">Enable scheduling</div>
                            <div class="setting-desc">Only transcode during set hours</div>
                        </div>
                        <div class="setting-control">
                            <input type="checkbox" id="setting-schedule-enabled" onchange="updateScheduleSetting()">
                        </div>
                    </div>
                    <div class="setting-item" id="schedule-hours-row">
                        <div class="setting-info">
                            <div class="setting-name">Transcode window</div>
                            <div class="setting-desc">Start and end time</div>
                        </div>
                        <div class="setting-control" style="display: flex; gap: 8px; align-items: center;">
                            <select class="setting-select" id="setting-schedule-start" style="min-width: 100px" onchange="updateScheduleSetting()">
                            </select>
                            <span style="color: var(--text-secondary)">to</span>
                            <select class="setting-select" id="setting-schedule-end" style="min-width: 100px" onchange="updateScheduleSetting()">
                            </select>
                        </div>
                    </div>
                </div>
                <div class="setting-group">
                    <div class="setting-group-title">Notifications</div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">Pushover User Key</div>
                            <div class="setting-desc">Your Pushover user/group key</div>
                        </div>
                        <div class="setting-control">
                            <input type="text" class="setting-input" id="setting-pushover-user"
                                   placeholder="Enter user key" onchange="updateSetting('pushover_user_key', this.value)">
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">Pushover App Token</div>
                            <div class="setting-desc">Your Pushover application token</div>
                        </div>
                        <div class="setting-control">
                            <input type="text" class="setting-input" id="setting-pushover-token"
                                   placeholder="Enter app token" onchange="updateSetting('pushover_app_token', this.value)">
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">Test Notification</div>
                            <div class="setting-desc">Send a test to verify setup</div>
                        </div>
                        <div class="setting-control">
                            <button class="btn btn-secondary btn-sm" id="test-pushover-btn" onclick="testPushover()">Test</button>
                        </div>
                    </div>
                </div>
                <div class="setting-group collapsed" id="advanced-settings">
                    <div class="setting-group-header" onclick="toggleAdvancedSettings()">
                        <div class="setting-group-title">Advanced</div>
                        <svg class="setting-group-toggle" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="6 9 12 15 18 9"/>
                        </svg>
                    </div>
                    <div class="setting-group-content">
                        <div class="setting-warning">
                            These settings are for advanced users. Don't change them unless you know what you're doing.
                        </div>
                        <div class="setting-item setting-item-stacked">
                            <div class="setting-info">
                                <div class="setting-name">HEVC Quality (CRF)</div>
                                <div class="setting-desc">Lower = higher quality, larger file</div>
                            </div>
                            <div class="setting-control">
                                <div class="quality-slider-container">
                                    <span class="quality-label">Higher quality</span>
                                    <input type="range" class="quality-slider" id="setting-quality-hevc"
                                           min="15" max="40" value="26"
                                           oninput="syncQualityInput('hevc', this.value)"
                                           onchange="updateSetting('quality_hevc', parseInt(this.value))">
                                    <span class="quality-label">Smaller file</span>
                                    <input type="number" class="quality-input" id="setting-quality-hevc-input"
                                           min="15" max="40" value="26"
                                           onchange="syncQualitySlider('hevc', this.value); updateSetting('quality_hevc', parseInt(document.getElementById('setting-quality-hevc').value))">
                                </div>
                            </div>
                        </div>
                        <div class="setting-item setting-item-stacked">
                            <div class="setting-info">
                                <div class="setting-name">AV1 Quality (CRF)</div>
                                <div class="setting-desc">Lower = higher quality, larger file</div>
                            </div>
                            <div class="setting-control">
                                <div class="quality-slider-container">
                                    <span class="quality-label">Higher quality</span>
                                    <input type="range" class="quality-slider" id="setting-quality-av1"
                                           min="20" max="50" value="35"
                                           oninput="syncQualityInput('av1', this.value)"
                                           onchange="updateSetting('quality_av1', parseInt(this.value))">
                                    <span class="quality-label">Smaller file</span>
                                    <input type="number" class="quality-input" id="setting-quality-av1-input"
                                           min="20" max="50" value="35"
                                           onchange="syncQualitySlider('av1', this.value); updateSetting('quality_av1', parseInt(document.getElementById('setting-quality-av1').value))">
                                </div>
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="setting-info">
                                <div class="setting-name">Output Container</div>
                                <div class="setting-desc">MP4 converts audio to AAC stereo and strips subtitles</div>
                            </div>
                            <div class="setting-control">
                                <select class="setting-select" id="setting-output-format"
                                        onchange="updateSetting('output_format', this.value)">
                                    <option value="mkv">MKV (preserves all streams)</option>
                                    <option value="mp4">MP4 (web compatible)</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="settings-status" id="settings-status"></div>
            <div class="settings-footer">Shrinkray v<span id="app-version"></span></div>
        </div>
    </div>

    <!-- Confirm Modal -->
    <div id="confirm-modal" class="modal-overlay" onclick="closeConfirmModal(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-title" id="confirm-modal-title">Confirm</div>
            <div class="modal-message" id="confirm-modal-message"></div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeConfirmModal()">Cancel</button>
                <button class="btn btn-primary" id="confirm-modal-action">Confirm</button>
            </div>
        </div>
    </div>

    <script>
        // Initialize theme immediately to prevent flash
        (function initTheme() {
            const saved = localStorage.getItem('theme');
            if (saved === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark');
            }
        })();

        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        }

        let currentPath = '';
        let mediaRoot = '';  // Will be set on first browse
        let selectedPaths = new Set();
        let selectedFileCounts = new Map();  // Track file count for each selected path (1 for files, N for folders)
        let totalSelectableCount = 0;  // Track total selectable items to avoid DOM queries
        let eventSource = null;

        function formatBytes(bytes) {
            if (bytes === 0) return '0';
            if (bytes < 0) return '0';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatDuration(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            if (h > 0) return `${h}h ${m}m`;
            if (m > 0) return `${m}m ${s}s`;
            return `${s}s`;
        }

        async function browse(path = '') {
            try {
                const url = path ? `/api/browse?path=${encodeURIComponent(path)}` : '/api/browse';
                const resp = await fetch(url);
                const data = await resp.json();

                currentPath = data.path;
                selectedPaths.clear();
                selectedFileCounts.clear();
                updateButtons();

                // Update breadcrumb
                const breadcrumb = document.getElementById('breadcrumb');

                // Store media root on first browse (when at root, there's no parent)
                if (!mediaRoot || !data.parent) {
                    mediaRoot = data.path;
                }

                let crumbs = `<a href="#" onclick="browse(''); return false;">Home</a>`;

                if (data.path !== mediaRoot) {
                    // Get the relative path from media root
                    const relativePath = data.path.substring(mediaRoot.length);
                    const segments = relativePath.split('/').filter(s => s);
                    const MAX_VISIBLE_SEGMENTS = 3;

                    if (segments.length > MAX_VISIBLE_SEGMENTS) {
                        // Collapse middle segments: Home / ... / last 3 segments
                        crumbs += `<span class="breadcrumb-sep">/</span>`;
                        crumbs += `<span class="breadcrumb-collapsed">...</span>`;

                        const startIndex = segments.length - MAX_VISIBLE_SEGMENTS;
                        let cumulativePath = mediaRoot + '/' + segments.slice(0, startIndex).join('/');

                        for (let i = startIndex; i < segments.length; i++) {
                            cumulativePath += '/' + segments[i];
                            crumbs += `<span class="breadcrumb-sep">/</span>`;

                            if (i === segments.length - 1) {
                                crumbs += `<span class="breadcrumb-current">${segments[i]}</span>`;
                            } else {
                                crumbs += `<a href="#" onclick="browse('${cumulativePath}'); return false;">${segments[i]}</a>`;
                            }
                        }
                    } else {
                        // Show full path
                        let cumulativePath = mediaRoot;
                        segments.forEach((segment, index) => {
                            cumulativePath += '/' + segment;
                            crumbs += `<span class="breadcrumb-sep">/</span>`;

                            if (index === segments.length - 1) {
                                crumbs += `<span class="breadcrumb-current">${segment}</span>`;
                            } else {
                                crumbs += `<a href="#" onclick="browse('${cumulativePath}'); return false;">${segment}</a>`;
                            }
                        });
                    }
                }

                breadcrumb.innerHTML = crumbs;

                // Update file list
                const list = document.getElementById('file-list');
                if (data.entries.length === 0) {
                    list.innerHTML = '<li class="file-list-empty">This folder is empty</li>';
                    document.getElementById('file-list-header').classList.add('hidden');
                    return;
                }

                // Count selectable items (videos or folders) to avoid DOM queries later
                totalSelectableCount = data.entries.filter(e =>
                    (!e.is_dir && e.video_info) || e.is_dir
                ).length;
                const header = document.getElementById('file-list-header');
                const selectAllCheckbox = document.getElementById('select-all-checkbox');

                if (totalSelectableCount > 0) {
                    header.classList.remove('hidden');
                } else {
                    header.classList.add('hidden');
                }
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;

                list.innerHTML = data.entries.map(entry => {
                    const isVideo = !entry.is_dir && entry.video_info;
                    const isFolder = entry.is_dir;
                    const isSelectable = isVideo || isFolder;
                    const iconClass = entry.is_dir ? 'folder' : (isVideo ? 'video' : 'other');
                    const icon = entry.is_dir
                        ? `<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"/></svg>`
                        : isVideo
                            ? `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>`
                            : `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>`;

                    let metaHtml = '';
                    // For folders, file_count is the number of videos inside; for videos it's 1
                    const fileCount = entry.is_dir ? (entry.file_count || 0) : (isVideo ? 1 : 0);
                    if (entry.is_dir) {
                        const count = entry.file_count || 0;
                        if (count > 0) {
                            const size = formatBytes(entry.total_size || 0);
                            metaHtml = `<span>${count} video${count !== 1 ? 's' : ''}</span><span>${size}</span>`;
                        }
                    } else if (isVideo) {
                        const vi = entry.video_info;
                        const codec = vi.video_codec?.toLowerCase() || '';
                        let codecClass = 'h264';
                        if (codec.includes('hevc') || codec.includes('h265')) {
                            codecClass = 'hevc';
                        } else if (codec.includes('av1')) {
                            codecClass = 'av1';
                        }
                        metaHtml = `<span class="codec-badge ${codecClass}">${vi.video_codec}</span><span>${vi.width}x${vi.height}</span>`;
                    }

                    return `<li class="file-item" data-path="${entry.path}" data-is-dir="${entry.is_dir}" onclick="handleFileClick(this, event)">
                        ${isSelectable ? `<input type="checkbox" class="file-checkbox" onclick="handleCheckbox(this, event)" data-path="${entry.path}" data-file-count="${fileCount}">` : '<div style="width: 18px"></div>'}
                        <div class="file-icon ${iconClass}">${icon}</div>
                        <div class="file-info">
                            <div class="file-name">${entry.name}</div>
                            <div class="file-meta">${metaHtml}</div>
                        </div>
                        ${entry.is_dir ? '' : `<div class="file-size">${formatBytes(entry.size)}</div>`}
                    </li>`;
                }).join('');

            } catch (err) {
                console.error('Browse error:', err);
            }
        }

        function handleCheckbox(checkbox, event) {
            event.stopPropagation();
            const path = checkbox.dataset.path;
            const fileCount = parseInt(checkbox.dataset.fileCount) || 1;
            const row = checkbox.closest('.file-item');

            if (checkbox.checked) {
                selectedPaths.add(path);
                selectedFileCounts.set(path, fileCount);
                row.classList.add('selected');
            } else {
                selectedPaths.delete(path);
                selectedFileCounts.delete(path);
                row.classList.remove('selected');
            }
            updateButtons();
        }

        function handleFileClick(el, event) {
            if (event.target.classList.contains('file-checkbox')) return;

            const path = el.dataset.path;
            const isDir = el.dataset.isDir === 'true';

            if (isDir) {
                browse(path);
            } else {
                const checkbox = el.querySelector('.file-checkbox');
                if (checkbox) {
                    const fileCount = parseInt(checkbox.dataset.fileCount) || 1;
                    checkbox.checked = !checkbox.checked;
                    if (checkbox.checked) {
                        selectedPaths.add(path);
                        selectedFileCounts.set(path, fileCount);
                        el.classList.add('selected');
                    } else {
                        selectedPaths.delete(path);
                        selectedFileCounts.delete(path);
                        el.classList.remove('selected');
                    }
                    updateButtons();
                }
            }
        }

        function toggleSelectAll(checkbox) {
            const isChecked = checkbox.checked;
            const allCheckboxes = document.querySelectorAll('.file-item .file-checkbox');

            // Batch DOM operations: collect all data first (reads), then do all updates (writes)
            const items = [];
            allCheckboxes.forEach(cb => {
                items.push({
                    cb,
                    row: cb.closest('.file-item'),
                    path: cb.dataset.path,
                    fileCount: parseInt(cb.dataset.fileCount) || 1
                });
            });

            // Clear or populate selectedPaths in one go
            if (isChecked) {
                items.forEach(({cb, row, path, fileCount}) => {
                    cb.checked = true;
                    row.classList.add('selected');
                    selectedPaths.add(path);
                    selectedFileCounts.set(path, fileCount);
                });
            } else {
                selectedPaths.clear();
                selectedFileCounts.clear();
                items.forEach(({cb, row}) => {
                    cb.checked = false;
                    row.classList.remove('selected');
                });
            }
            updateButtons();
        }

        function updateButtons() {
            const hasSelection = selectedPaths.size > 0;
            document.getElementById('start-btn').disabled = !hasSelection;

            const summary = document.getElementById('selection-summary');
            if (hasSelection) {
                summary.textContent = `${selectedPaths.size} file${selectedPaths.size > 1 ? 's' : ''} selected`;
            } else {
                summary.textContent = '';
            }

            // Update select-all checkbox using cached count (avoids O(n) DOM query)
            const selectAllCheckbox = document.getElementById('select-all-checkbox');
            if (totalSelectableCount > 0) {
                const allChecked = selectedPaths.size === totalSelectableCount;
                const someChecked = selectedPaths.size > 0;
                selectAllCheckbox.checked = allChecked;
                selectAllCheckbox.indeterminate = someChecked && !allChecked;
            }
        }

        function onPresetChange() {
            // Preset changed - no action needed since estimation is removed
        }

        async function startJobs() {
            if (selectedPaths.size === 0) return;

            const banner = document.getElementById('processing-banner');
            try {
                const preset = document.getElementById('preset-select').value;
                // Sum up total files: for folders use their file_count, for files use 1
                let totalFiles = 0;
                for (const count of selectedFileCounts.values()) {
                    totalFiles += count;
                }

                // Show processing indicator BEFORE fetch to avoid race condition
                // (backend may send jobs_added SSE before fetch returns)
                document.getElementById('processing-text').textContent =
                    `Processing ${totalFiles} file${totalFiles !== 1 ? 's' : ''}...`;
                banner.classList.remove('hidden');

                const resp = await fetch('/api/jobs', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        paths: Array.from(selectedPaths),
                        preset_id: preset
                    })
                });
                const data = await resp.json();

                // Check for validation errors (bad request)
                if (data.error) {
                    banner.classList.add('hidden');
                    alert(data.error);
                    return;
                }

                // Clear selections immediately - jobs will appear via SSE as they're processed
                selectedPaths.clear();
                selectedFileCounts.clear();
                document.querySelectorAll('.file-item.selected').forEach(el => {
                    el.classList.remove('selected');
                    const cb = el.querySelector('.file-checkbox');
                    if (cb) cb.checked = false;
                });
                updateButtons();

                // Reset select-all checkbox
                const selectAllCheckbox = document.getElementById('select-all-checkbox');
                if (selectAllCheckbox) {
                    selectAllCheckbox.checked = false;
                    selectAllCheckbox.indeterminate = false;
                }

            } catch (err) {
                banner.classList.add('hidden');
                console.error('Start jobs error:', err);
            }
        }

        async function cancelJob(id) {
            try {
                await fetch(`/api/jobs/${id}`, { method: 'DELETE' });
            } catch (err) {
                console.error('Cancel error:', err);
            }
        }

        async function retryJob(id) {
            try {
                const resp = await fetch(`/api/jobs/${id}/retry`, { method: 'POST' });
                if (!resp.ok) {
                    const data = await resp.json();
                    alert(data.error || 'Failed to retry job');
                }
            } catch (err) {
                console.error('Retry error:', err);
            }
        }

        function clearQueue() {
            const message = queueFilter === 'all'
                ? 'This will remove all non-active jobs from the queue (including pending jobs). Your active jobs will not be affected.'
                : `This will remove all ${queueFilter} jobs from the queue.`;

            showConfirmModal(
                'Clear Jobs',
                message,
                async () => {
                    try {
                        const url = queueFilter === 'all'
                            ? '/api/jobs/clear'
                            : `/api/jobs/clear?status=${queueFilter}`;
                        await fetch(url, { method: 'POST' });
                        refreshJobs();
                    } catch (err) {
                        console.error('Clear error:', err);
                    }
                }
            );
        }

        // Stop/Resume Queue
        let queuePaused = false;

        function updateStopResumeButton() {
            const btn = document.getElementById('stop-resume-btn');
            if (!btn) return;
            btn.textContent = queuePaused ? 'Resume' : 'Stop All';
        }

        function toggleStopResume() {
            if (queuePaused) {
                resumeQueue();
            } else {
                pauseQueue();
            }
        }

        function pauseQueue() {
            // Check if there are running jobs first
            const hasRunningJobs = allSortedJobs.some(j => j.status === 'running');

            if (!hasRunningJobs) {
                showQueueError('No active jobs to stop');
                return;
            }

            showConfirmModal(
                'Stop Queue',
                'This will stop all running jobs. They will return to the queue but must restart from the beginning.',
                async () => {
                    try {
                        await fetch('/api/queue/pause', { method: 'POST' });
                        queuePaused = true;
                        updateStopResumeButton();
                        refreshJobs();
                    } catch (err) {
                        console.error('Pause error:', err);
                    }
                }
            );
        }

        async function resumeQueue() {
            try {
                await fetch('/api/queue/resume', { method: 'POST' });
                queuePaused = false;
                updateStopResumeButton();
                refreshJobs();
            } catch (err) {
                console.error('Resume error:', err);
            }
        }

        function showQueueError(message) {
            const el = document.getElementById('queue-error');
            if (!el) return;
            el.textContent = message;
            setTimeout(() => {
                el.textContent = '';
            }, 3000);
        }

        // Confirm Modal
        let confirmCallback = null;

        function showConfirmModal(title, message, onConfirm) {
            document.getElementById('confirm-modal-title').textContent = title;
            document.getElementById('confirm-modal-message').textContent = message;
            confirmCallback = onConfirm;
            document.getElementById('confirm-modal').classList.add('active');
        }

        function closeConfirmModal(event) {
            // If called from overlay click, only close if clicking the overlay itself
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('confirm-modal').classList.remove('active');
            confirmCallback = null;
        }

        document.getElementById('confirm-modal-action').addEventListener('click', () => {
            if (confirmCallback) {
                confirmCallback();
            }
            closeConfirmModal();
        });

        async function refreshJobs() {
            try {
                const resp = await fetch('/api/jobs');
                const data = await resp.json();
                updateJobs(data.jobs);
                updateStats(data.stats);
            } catch (err) {
                console.error('Refresh error:', err);
            }
        }

        // Helper to render a single job's HTML
        function renderJobHTML(job) {
            const filename = job.input_path.split('/').pop();
            const isInitializing = job.status === 'running' && job.progress === 0 && job.speed === 0;
            const statusClass = isInitializing ? 'initializing' : job.status;
            const statusLabel = isInitializing ? 'Initializing' : job.status.charAt(0).toUpperCase() + job.status.slice(1);

            let detailsHtml = '';
            if (job.status === 'running') {
                if (isInitializing) {
                    detailsHtml = '<span class="job-detail">Starting encoder...</span>';
                } else {
                    detailsHtml = `
                        <span class="job-detail"><span class="job-detail-value">${job.progress.toFixed(1)}%</span></span>
                        <span class="job-detail"><span class="job-detail-value">${job.speed.toFixed(2)}x</span></span>
                        <span class="job-detail">ETA: <span class="job-detail-value">${job.eta || '...'}</span></span>
                    `;
                }
            } else if (job.status === 'complete') {
                detailsHtml = `
                    <span class="job-detail job-saved">Saved <span class="job-detail-value">${formatBytes(job.space_saved)}</span></span>
                    <span class="job-detail">${formatBytes(job.input_size)}  ${formatBytes(job.output_size)}</span>
                    ${job.transcode_secs ? `<span class="job-detail">in <span class="job-detail-value">${formatDuration(job.transcode_secs)}</span></span>` : ''}
                `;
            }

            return `
                <div class="job-item" data-job-id="${job.id}">
                    <div class="job-header">
                        <span class="job-name" title="${job.input_path}">${filename}</span>
                        <div class="job-badges">
                            <span class="job-badge ${job.is_hardware ? 'hardware' : 'software'}">${job.is_hardware ? 'HW' : 'SW'}</span>
                            <span class="job-badge ${statusClass}">${statusLabel}</span>
                        </div>
                    </div>
                    ${job.status === 'running' ? `
                        <div class="job-progress">
                            <div class="progress-bar">
                                <div class="progress-fill ${isInitializing ? 'initializing' : ''}" style="width: ${isInitializing ? 100 : job.progress}%"></div>
                            </div>
                        </div>
                    ` : ''}
                    <div class="job-details">${detailsHtml}</div>
                    ${job.status === 'failed' ? `<div class="job-error">${job.error}</div>` : ''}
                    ${job.status === 'pending' || job.status === 'running' ? `
                        <div class="job-actions">
                            <button class="btn btn-secondary btn-sm" onclick="cancelJob('${job.id}')">Cancel</button>
                        </div>
                    ` : ''}
                    ${job.status === 'failed' ? `
                        <div class="job-actions">
                            <button class="btn btn-secondary btn-sm" onclick="retryJob('${job.id}')">Retry</button>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // Incremental DOM update functions (avoid full rebuilds)
        function updateJobProgress(jobId, progress, speed, eta) {
            const el = document.querySelector(`.job-item[data-job-id="${jobId}"]`);
            if (!el) return;

            // Update progress bar
            const progressFill = el.querySelector('.progress-fill');
            if (progressFill) {
                progressFill.style.width = progress + '%';
                progressFill.classList.remove('initializing');
            }

            // Update status badge if transitioning from initializing to running
            // (initializing = progress=0 && speed=0, running = progress>0 || speed>0)
            const statusBadge = el.querySelector('.job-badge.initializing');
            if (statusBadge && (progress > 0 || speed > 0)) {
                statusBadge.classList.remove('initializing');
                statusBadge.classList.add('running');
                statusBadge.textContent = 'Running';
            }

            // Update text values - find the job-details container
            const detailsEl = el.querySelector('.job-details');
            if (detailsEl) {
                detailsEl.innerHTML = `
                    <span class="job-detail"><span class="job-detail-value">${progress.toFixed(1)}%</span></span>
                    <span class="job-detail"><span class="job-detail-value">${speed.toFixed(2)}x</span></span>
                    <span class="job-detail">ETA: <span class="job-detail-value">${eta || '...'}</span></span>
                `;
            }

            // Update in allSortedJobs array for consistency
            const job = allSortedJobs.find(j => j.id === jobId);
            if (job) {
                job.progress = progress;
                job.speed = speed;
                job.eta = eta;
            }
        }

        function updateJobStatus(updatedJob) {
            const statusOrder = { running: 0, pending: 1, failed: 2, complete: 3, cancelled: 4 };

            // Find current index before update
            const oldIdx = allSortedJobs.findIndex(j => j.id === updatedJob.id);

            // Update or add job in array
            if (oldIdx !== -1) {
                allSortedJobs[oldIdx] = updatedJob;
            } else {
                allSortedJobs.push(updatedJob);
            }

            // Re-sort array
            allSortedJobs.sort((a, b) => {
                const orderA = statusOrder[a.status] ?? 5;
                const orderB = statusOrder[b.status] ?? 5;
                if (orderA !== orderB) return orderA - orderB;

                // Secondary sort by timestamp
                // Pending: oldest first (FIFO). Others: most recent first.
                if (a.status === 'pending') {
                    return (a.created_at || '').localeCompare(b.created_at || '');
                }
                // Running/Complete/Failed/Cancelled: most recent first
                const timeA = a.completed_at || a.started_at || '';
                const timeB = b.completed_at || b.started_at || '';
                return timeB.localeCompare(timeA);
            });

            // Find new position after sort
            const newIdx = allSortedJobs.findIndex(j => j.id === updatedJob.id);

            // Find existing DOM element
            const container = document.getElementById('queue-list');
            const existingEl = container.querySelector(`.job-item[data-job-id="${updatedJob.id}"]`);

            // Check if job matches current filter
            const matchesFilter = queueFilter === 'all' || updatedJob.status === queueFilter;

            // If element not in DOM
            if (!existingEl) {
                // If job now matches filter, add it to the view
                if (matchesFilter) {
                    // Remove empty state if present
                    const emptyState = container.querySelector('.queue-empty');
                    if (emptyState) emptyState.remove();

                    // Find position in filtered list and add
                    const filteredJobs = getFilteredJobs();
                    const filteredIdx = filteredJobs.findIndex(j => j.id === updatedJob.id);

                    if (filteredIdx !== -1 && filteredIdx < displayedJobCount + 1) {
                        const temp = document.createElement('div');
                        temp.innerHTML = renderJobHTML(updatedJob);
                        const newEl = temp.firstElementChild;

                        if (filteredIdx === 0) {
                            const firstJob = container.querySelector('.job-item');
                            if (firstJob) {
                                firstJob.before(newEl);
                            } else {
                                container.appendChild(newEl);
                            }
                        } else {
                            const prevJob = filteredJobs[filteredIdx - 1];
                            const prevEl = container.querySelector(`.job-item[data-job-id="${prevJob.id}"]`);
                            if (prevEl) {
                                prevEl.after(newEl);
                            } else {
                                container.appendChild(newEl);
                            }
                        }
                        displayedJobCount++;
                    }
                }
                return;
            }

            // If job no longer matches current filter, just remove it
            if (!matchesFilter) {
                existingEl.remove();
                displayedJobCount--;
                // Show empty state if no more jobs visible
                if (displayedJobCount === 0) {
                    loadMoreJobs();
                }
                return;
            }

            // Create new element HTML
            const temp = document.createElement('div');
            temp.innerHTML = renderJobHTML(updatedJob);
            const newEl = temp.firstElementChild;

            // If position unchanged, just replace content
            if (oldIdx === newIdx) {
                existingEl.replaceWith(newEl);
                return;
            }

            // Position changed - remove old element
            existingEl.remove();

            // Check if new position is within displayed range
            if (newIdx >= displayedJobCount) {
                // Job moved beyond visible range, don't re-insert
                displayedJobCount--;
                return;
            }

            // Insert at new position
            if (newIdx === 0) {
                // Insert at beginning (before first .job-item, after any banners)
                const firstJob = container.querySelector('.job-item');
                if (firstJob) {
                    firstJob.before(newEl);
                } else {
                    container.appendChild(newEl);
                }
            } else {
                // Insert after previous job
                const prevJob = allSortedJobs[newIdx - 1];
                const prevEl = container.querySelector(`.job-item[data-job-id="${prevJob.id}"]`);
                if (prevEl) {
                    prevEl.after(newEl);
                } else {
                    // Previous job not rendered, append (edge case)
                    container.appendChild(newEl);
                }
            }
        }

        function addJobToList(job) {
            // Check if job already exists
            if (allSortedJobs.find(j => j.id === job.id)) return;

            allSortedJobs.push(job);
            // Re-sort
            const statusOrder = { running: 0, pending: 1, failed: 2, complete: 3, cancelled: 4 };
            allSortedJobs.sort((a, b) => {
                const orderA = statusOrder[a.status] ?? 5;
                const orderB = statusOrder[b.status] ?? 5;
                if (orderA !== orderB) return orderA - orderB;

                // Secondary sort by timestamp
                // Pending: oldest first (FIFO). Others: most recent first.
                if (a.status === 'pending') {
                    return (a.created_at || '').localeCompare(b.created_at || '');
                }
                // Running/Complete/Failed/Cancelled: most recent first
                const timeA = a.completed_at || a.started_at || '';
                const timeB = b.completed_at || b.started_at || '';
                return timeB.localeCompare(timeA);
            });

            // Remove empty state if present
            const container = document.getElementById('queue-list');
            const emptyState = container.querySelector('.queue-empty');
            if (emptyState) emptyState.remove();

            // Find insertion point and insert
            const newIdx = allSortedJobs.findIndex(j => j.id === job.id);
            const temp = document.createElement('div');
            temp.innerHTML = renderJobHTML(job);

            if (newIdx === 0 || container.children.length === 0) {
                container.prepend(temp.firstElementChild);
            } else {
                const prevJob = allSortedJobs[newIdx - 1];
                const prevEl = container.querySelector(`.job-item[data-job-id="${prevJob.id}"]`);
                if (prevEl) {
                    prevEl.after(temp.firstElementChild);
                } else {
                    container.appendChild(temp.firstElementChild);
                }
            }
            displayedJobCount++;
        }

        // Infinite scroll state
        const JOBS_PER_PAGE = 50;
        let allSortedJobs = [];
        let displayedJobCount = 0;
        let queueFilter = 'all'; // 'all', 'running', 'pending', 'failed', 'complete', 'cancelled'

        function setQueueFilter(filter) {
            queueFilter = filter;
            displayedJobCount = 0;
            const container = document.getElementById('queue-list');
            container.innerHTML = '';
            loadMoreJobs();
            // Disable Clear button for running filter (can't clear running jobs)
            document.getElementById('clear-btn').disabled = filter === 'running';
        }

        function getFilteredJobs() {
            if (queueFilter === 'all') return allSortedJobs;
            return allSortedJobs.filter(j => j.status === queueFilter);
        }

        function updateJobs(jobs) {
            const container = document.getElementById('queue-list');

            // Save scroll position before DOM rebuild
            const savedScrollTop = container.scrollTop;

            if (!jobs || jobs.length === 0) {
                allSortedJobs = [];
                displayedJobCount = 0;
                container.innerHTML = `
                    <div class="queue-empty">
                        <div class="queue-empty-icon">
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.3">
                                <rect x="3" y="3" width="18" height="18" rx="2"/>
                                <path d="M3 9h18"/>
                                <path d="M9 21V9"/>
                            </svg>
                        </div>
                        <div>No jobs in queue</div>
                        <div style="font-size: 0.8125rem; margin-top: 4px; color: var(--text-tertiary)">Select files and start transcoding</div>
                    </div>
                `;
                // No jobs, so not paused
                queuePaused = false;
                updateStopResumeButton();
                return;
            }

            // Sort jobs by status: running first, then pending, failed, completed
            const statusOrder = { running: 0, pending: 1, failed: 2, complete: 3, cancelled: 4 };
            allSortedJobs = [...jobs].sort((a, b) => {
                const orderA = statusOrder[a.status] ?? 5;
                const orderB = statusOrder[b.status] ?? 5;
                if (orderA !== orderB) return orderA - orderB;

                // Secondary sort by timestamp
                // Pending: oldest first (FIFO). Others: most recent first.
                if (a.status === 'pending') {
                    return (a.created_at || '').localeCompare(b.created_at || '');
                }
                // Running/Complete/Failed/Cancelled: most recent first
                const timeA = a.completed_at || a.started_at || '';
                const timeB = b.completed_at || b.started_at || '';
                return timeB.localeCompare(timeA);
            });

            // Render initial batch
            displayedJobCount = 0;
            container.innerHTML = '';
            loadMoreJobs();

            // Restore scroll position after DOM rebuild
            requestAnimationFrame(() => {
                container.scrollTop = Math.min(savedScrollTop, container.scrollHeight - container.clientHeight);
            });

            // Sync Stop/Resume button state
            const hasRunningJobs = jobs.some(j => j.status === 'running');
            const hasPendingJobs = jobs.some(j => j.status === 'pending');

            // If jobs are running, we're not paused
            if (hasRunningJobs) {
                queuePaused = false;
            }
            // If paused but no pending jobs, clear pause (nothing to resume)
            if (queuePaused && !hasPendingJobs) {
                queuePaused = false;
            }
            updateStopResumeButton();
        }

        function loadMoreJobs() {
            const filteredJobs = getFilteredJobs();
            const container = document.getElementById('queue-list');

            // Show empty state if no jobs match filter
            if (filteredJobs.length === 0 && displayedJobCount === 0) {
                if (queueFilter === 'all') {
                    // Full empty state for "All" filter
                    container.innerHTML = `
                        <div class="queue-empty">
                            <div class="queue-empty-icon">
                                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.3">
                                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                                    <path d="M3 9h18"/>
                                    <path d="M9 21V9"/>
                                </svg>
                            </div>
                            <div>No jobs in queue</div>
                            <div style="font-size: 0.8125rem; margin-top: 4px; color: var(--text-tertiary)">Select files and start transcoding</div>
                        </div>
                    `;
                } else {
                    // Filtered empty state
                    container.innerHTML = `
                        <div class="queue-empty">
                            <div class="queue-empty-icon">
                                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.3">
                                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                                    <path d="M3 9h18"/>
                                    <path d="M9 21V9"/>
                                </svg>
                            </div>
                            <div>No ${queueFilter} jobs</div>
                        </div>
                    `;
                }
                return;
            }

            if (displayedJobCount >= filteredJobs.length) return;

            const fragment = document.createDocumentFragment();
            const temp = document.createElement('div');

            const endIndex = Math.min(displayedJobCount + JOBS_PER_PAGE, filteredJobs.length);
            for (let i = displayedJobCount; i < endIndex; i++) {
                temp.innerHTML = renderJobHTML(filteredJobs[i]);
                fragment.appendChild(temp.firstElementChild);
            }

            // Remove existing "load more" indicator if present
            const existingIndicator = container.querySelector('.load-more-indicator');
            if (existingIndicator) existingIndicator.remove();

            container.appendChild(fragment);
            displayedJobCount = endIndex;

            // Add "scroll for more" indicator if there are more jobs
            if (displayedJobCount < filteredJobs.length) {
                const remaining = filteredJobs.length - displayedJobCount;
                const indicator = document.createElement('div');
                indicator.className = 'load-more-indicator';
                indicator.style.cssText = 'text-align: center; padding: 16px; color: var(--text-secondary); font-size: 0.875rem;';
                indicator.textContent = `Scroll for ${remaining.toLocaleString()} more jobs...`;
                container.appendChild(indicator);
            }
        }

        // Set up infinite scroll listener
        (function setupInfiniteScroll() {
            const container = document.getElementById('queue-list');
            container.addEventListener('scroll', () => {
                // Load more when scrolled near bottom (within 100px)
                const nearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100;
                if (nearBottom && displayedJobCount < getFilteredJobs().length) {
                    loadMoreJobs();
                }
            });
        })();

        function updateStats(stats) {
            document.getElementById('stat-pending').textContent = stats.pending;
            document.getElementById('stat-running').textContent = stats.running;

            // Header shows session saved
            const sessionSaved = Math.max(0, stats.session_saved || stats.total_saved || 0);
            document.getElementById('stat-saved').textContent = formatBytes(sessionSaved);

            // Dropdown values
            const sessionEl = document.getElementById('stat-session-saved');
            const lifetimeEl = document.getElementById('stat-lifetime-saved');
            if (sessionEl) sessionEl.textContent = formatBytes(sessionSaved);
            if (lifetimeEl) lifetimeEl.textContent = formatBytes(Math.max(0, stats.lifetime_saved || 0));
        }

        function toggleSavedDropdown(event) {
            event.stopPropagation();
            document.getElementById('stat-saved-wrapper').classList.toggle('open');
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const wrapper = document.getElementById('stat-saved-wrapper');
            if (wrapper && !wrapper.contains(event.target)) {
                wrapper.classList.remove('open');
            }
        });

        async function resetSession(event) {
            event.stopPropagation();
            try {
                const response = await fetch('/api/stats/reset-session', { method: 'POST' });
                if (!response.ok) throw new Error('Failed to reset');

                // Refresh stats
                const statsResp = await fetch('/api/stats');
                const stats = await statsResp.json();
                updateStats(stats);

                // Close dropdown
                document.getElementById('stat-saved-wrapper').classList.remove('open');
            } catch (err) {
                console.error('Reset session failed:', err);
            }
        }

        // Debounced refresh to avoid UI thrashing when many jobs are added
        let refreshTimeout = null;
        let browseTimeout = null;
        let statsTimeout = null;
        function scheduleRefresh() {
            if (!refreshTimeout) {
                refreshTimeout = setTimeout(() => {
                    refreshTimeout = null;
                    refreshJobs();
                }, 200);
            }
        }
        function scheduleBrowseRefresh() {
            if (!browseTimeout) {
                browseTimeout = setTimeout(() => {
                    browseTimeout = null;
                    browse(currentPath);
                }, 500);
            }
        }
        function scheduleStatsRefresh() {
            if (!statsTimeout) {
                statsTimeout = setTimeout(async () => {
                    statsTimeout = null;
                    try {
                        const resp = await fetch('/api/stats');
                        const stats = await resp.json();
                        updateStats(stats);
                    } catch (err) {
                        console.error('Stats refresh error:', err);
                    }
                }, 200);
            }
        }

        function connectSSE() {
            if (eventSource) eventSource.close();

            eventSource = new EventSource('/api/jobs/stream');

            eventSource.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'init') {
                    updateJobs(data.jobs);
                    updateStats(data.stats);
                } else if (data.type === 'progress') {
                    // Incremental: update just progress bar (no DOM rebuild)
                    updateJobProgress(data.job.id, data.job.progress, data.job.speed, data.job.eta);
                } else if (data.type === 'started' || data.type === 'complete' ||
                           data.type === 'failed' || data.type === 'cancelled' ||
                           data.type === 'requeued') {
                    // Status change: update that specific job element
                    updateJobStatus(data.job);
                    scheduleStatsRefresh();
                    if (data.type === 'complete' || data.type === 'failed') {
                        scheduleBrowseRefresh();
                    }
                } else if (data.type === 'added') {
                    // Single job added
                    addJobToList(data.job);
                    scheduleStatsRefresh();
                } else if (data.type === 'jobs_added') {
                    // Batch of jobs finished processing, hide banner and full refresh
                    document.getElementById('processing-banner').classList.add('hidden');
                    scheduleRefresh();
                } else if (data.type === 'notify_sent') {
                    // Notification was sent, uncheck the checkbox
                    document.getElementById('notify-checkbox').checked = false;
                } else if (data.type === 'discovery_progress') {
                    // Update processing banner with progress
                    const banner = document.getElementById('processing-banner');
                    banner.classList.remove('hidden');
                    document.getElementById('processing-text').textContent =
                        `Processing file ${data.probed}/${data.total}...`;
                }
                // No catch-all scheduleRefresh() - only refresh when truly needed
            };

            eventSource.onerror = () => {
                setTimeout(connectSSE, 2000);
            };
        }

        // Settings
        function openSettings() {
            document.getElementById('settings-overlay').classList.add('open');
        }

        function closeSettings(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('settings-overlay').classList.remove('open');
        }

        async function loadSettings() {
            try {
                const resp = await fetch('/api/config');
                const config = await resp.json();

                // Display version
                if (config.version) {
                    document.getElementById('app-version').textContent = config.version;
                }

                document.getElementById('setting-original-handling').value = config.original_handling || 'replace';
                document.getElementById('setting-workers').value = config.workers || 1;

                // Pushover settings
                document.getElementById('setting-pushover-user').value = config.pushover_user_key || '';
                document.getElementById('setting-pushover-token').value = config.pushover_app_token || '';

                // Show/hide notify checkbox based on whether Pushover is configured
                const notifyContainer = document.getElementById('notify-container');
                const notifyCheckbox = document.getElementById('notify-checkbox');
                if (config.pushover_configured) {
                    notifyContainer.style.display = 'flex';
                    notifyCheckbox.checked = config.notify_on_complete || false;
                } else {
                    notifyContainer.style.display = 'none';
                }

                // Quality settings - use encoder-specific defaults when config value is 0
                const defaultHEVC = config.default_quality_hevc || 26;
                const defaultAV1 = config.default_quality_av1 || 35;
                const hevcQuality = config.quality_hevc || defaultHEVC;
                const av1Quality = config.quality_av1 || defaultAV1;
                document.getElementById('setting-quality-hevc').value = hevcQuality;
                document.getElementById('setting-quality-hevc-input').value = hevcQuality;
                document.getElementById('setting-quality-av1').value = av1Quality;
                document.getElementById('setting-quality-av1-input').value = av1Quality;

                // Schedule settings
                document.getElementById('setting-schedule-enabled').checked = config.schedule_enabled || false;
                document.getElementById('setting-schedule-start').value = config.schedule_start_hour ?? 22;
                document.getElementById('setting-schedule-end').value = config.schedule_end_hour ?? 6;
                updateScheduleHoursVisibility();

                // Output format
                document.getElementById('setting-output-format').value = config.output_format || 'mkv';
                updateScheduleStatusDisplay(config.schedule_enabled, config.schedule_start_hour ?? 22, config.schedule_end_hour ?? 6);
            } catch (err) {
                console.error('Load settings error:', err);
            }
        }

        function syncQualityInput(codec, value) {
            document.getElementById(`setting-quality-${codec}-input`).value = value;
        }

        function syncQualitySlider(codec, value) {
            const slider = document.getElementById(`setting-quality-${codec}`);
            const input = document.getElementById(`setting-quality-${codec}-input`);
            // Clamp value to valid range
            const min = parseInt(slider.min);
            const max = parseInt(slider.max);
            let val = parseInt(value) || min;
            if (val < min) val = min;
            if (val > max) val = max;
            slider.value = val;
            input.value = val;
        }

        function toggleAdvancedSettings() {
            document.getElementById('advanced-settings').classList.toggle('collapsed');
        }

        // Schedule functions
        function formatHour(hour) {
            if (hour === 0) return '12 AM';
            if (hour === 12) return '12 PM';
            if (hour < 12) return hour + ' AM';
            return (hour - 12) + ' PM';
        }

        function populateHourDropdowns() {
            const startSelect = document.getElementById('setting-schedule-start');
            const endSelect = document.getElementById('setting-schedule-end');
            let options = '';
            for (let h = 0; h < 24; h++) {
                options += `<option value="${h}">${formatHour(h)}</option>`;
            }
            startSelect.innerHTML = options;
            endSelect.innerHTML = options;
        }

        function updateScheduleHoursVisibility() {
            const enabled = document.getElementById('setting-schedule-enabled').checked;
            const hoursRow = document.getElementById('schedule-hours-row');
            hoursRow.style.opacity = enabled ? '1' : '0.5';
            hoursRow.style.pointerEvents = enabled ? 'auto' : 'none';
        }

        function updateScheduleStatusDisplay(enabled, startHour, endHour) {
            const statusEl = document.getElementById('schedule-status');
            if (!enabled) {
                statusEl.innerHTML = '';
                return;
            }
            const clockIcon = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>`;
            statusEl.innerHTML = `${clockIcon} ${formatHour(startHour)}  ${formatHour(endHour)}`;
        }

        async function updateScheduleSetting() {
            const enabled = document.getElementById('setting-schedule-enabled').checked;
            const startHour = parseInt(document.getElementById('setting-schedule-start').value);
            const endHour = parseInt(document.getElementById('setting-schedule-end').value);

            updateScheduleHoursVisibility();
            updateScheduleStatusDisplay(enabled, startHour, endHour);

            const statusEl = document.getElementById('settings-status');
            try {
                const resp = await fetch('/api/config', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        schedule_enabled: enabled,
                        schedule_start_hour: startHour,
                        schedule_end_hour: endHour
                    })
                });

                if (!resp.ok) {
                    const data = await resp.json();
                    throw new Error(data.error || 'Failed to update');
                }

                statusEl.textContent = 'Settings saved';
                statusEl.className = 'settings-status';
                setTimeout(() => { statusEl.textContent = ''; }, 2000);
            } catch (err) {
                statusEl.textContent = `Error: ${err.message}`;
                statusEl.className = 'settings-status error';
            }
        }

        async function updateSetting(key, value) {
            const statusEl = document.getElementById('settings-status');
            try {
                const body = {};
                body[key] = value;

                const resp = await fetch('/api/config', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });

                if (!resp.ok) {
                    const data = await resp.json();
                    throw new Error(data.error || 'Failed to update');
                }

                statusEl.textContent = 'Settings saved';
                statusEl.className = 'settings-status';
                setTimeout(() => { statusEl.textContent = ''; }, 2000);

                // Reload settings to update notify checkbox visibility
                if (key === 'pushover_user_key' || key === 'pushover_app_token') {
                    loadSettings();
                }
            } catch (err) {
                statusEl.textContent = `Error: ${err.message}`;
                statusEl.className = 'settings-status error';
            }
        }

        async function updateNotifySetting(checked) {
            try {
                await fetch('/api/config', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ notify_on_complete: checked })
                });
            } catch (err) {
                console.error('Update notify setting error:', err);
            }
        }

        async function testPushover() {
            const btn = document.getElementById('test-pushover-btn');
            const statusEl = document.getElementById('settings-status');
            btn.disabled = true;
            btn.textContent = 'Sending...';

            try {
                const resp = await fetch('/api/pushover/test', { method: 'POST' });
                const data = await resp.json();

                if (!resp.ok) {
                    throw new Error(data.error || 'Failed to send test');
                }

                statusEl.textContent = 'Test notification sent!';
                statusEl.className = 'settings-status';
                setTimeout(() => { statusEl.textContent = ''; }, 3000);
            } catch (err) {
                statusEl.textContent = `Error: ${err.message}`;
                statusEl.className = 'settings-status error';
            } finally {
                btn.disabled = false;
                btn.textContent = 'Test';
            }
        }

        async function loadPresets() {
            try {
                const presets = await fetch('/api/presets').then(r => r.json());
                const select = document.getElementById('preset-select');
                select.innerHTML = presets.map(p =>
                    `<option value="${p.id}">${p.name}</option>`
                ).join('');
            } catch (err) {
                console.error('Load presets error:', err);
            }
        }

        // Keyboard shortcut for settings
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeSettings();
            }
        });

        // Initialize
        populateHourDropdowns();
        browse();
        connectSSE();
        loadSettings();
        loadPresets();
    </script>
</body>
</html>
