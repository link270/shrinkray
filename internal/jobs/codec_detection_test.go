package jobs

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/gwlsn/shrinkray/internal/config"
	"github.com/gwlsn/shrinkray/internal/ffmpeg"
)

// TestCodecDetection runs comprehensive end-to-end tests for proactive codec detection
// and software decode fallback logic through the full Shrinkray pipeline.
//
// These tests require test vector files generated by testdata/generate_test_vectors.sh
func TestCodecDetection(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping codec detection integration test in short mode")
	}

	// Check if test vectors exist
	testdataDir, err := filepath.Abs(filepath.Join("..", "..", "testdata"))
	if err != nil {
		t.Fatalf("failed to get testdata path: %v", err)
	}

	// Check for critical test file
	criticalFile := filepath.Join(testdataDir, "test_h264_10bit_high10.mkv")
	if _, err := os.Stat(criticalFile); os.IsNotExist(err) {
		t.Skipf("test vectors not generated - run testdata/generate_test_vectors.sh first\n"+
			"Missing: %s", criticalFile)
	}

	tests := []struct {
		name                 string
		file                 string
		preset               string
		expectSoftwareDecode bool
		expectSkip           bool
		expectComplete       bool
		expectFail           bool
	}{
		// === H.264 Tests ===
		{
			name:                 "H264_8bit_High_HardwareDecode",
			file:                 "test_h264_8bit_high.mp4",
			preset:               "compress-hevc",
			expectSoftwareDecode: false,
			expectComplete:       true,
		},
		{
			name:                 "H264_10bit_High10_ProactiveSoftwareDecode",
			file:                 "test_h264_10bit_high10.mkv",
			preset:               "compress-hevc",
			expectSoftwareDecode: true, // CRITICAL: Issue #56 case
			expectComplete:       true,
		},
		{
			name:                 "H264_Short_1Second",
			file:                 "test_h264_short.mp4",
			preset:               "compress-hevc",
			expectSoftwareDecode: false,
			expectComplete:       true,
		},
		{
			name:                 "H264_60fps_HighFramerate",
			file:                 "test_h264_60fps.mp4",
			preset:               "compress-hevc",
			expectSoftwareDecode: false,
			expectComplete:       true,
		},
		{
			name:                 "H264_4K_LargeResolution",
			file:                 "test_h264_4k.mp4",
			preset:               "compress-hevc",
			expectSoftwareDecode: false,
			expectComplete:       true,
		},
		{
			name:                 "H264_LowBitrate_MayBeSkipped",
			file:                 "test_h264_lowbitrate.mp4",
			preset:               "compress-hevc",
			expectSoftwareDecode: false,
			// Low bitrate files may fail because output is larger
			expectComplete: false,
			expectFail:     true,
		},

		// === HEVC Tests (should be skipped - already target codec) ===
		{
			name:       "HEVC_8bit_Main_Skip",
			file:       "test_hevc_8bit_main.mkv",
			preset:     "compress-hevc",
			expectSkip: true,
		},
		{
			name:       "HEVC_10bit_Main10_Skip",
			file:       "test_hevc_10bit_main10.mkv",
			preset:     "compress-hevc",
			expectSkip: true,
		},

		// === VP9 Tests ===
		{
			name:                 "VP9_8bit_HardwareDecode",
			file:                 "test_vp9_8bit.webm",
			preset:               "compress-hevc",
			expectSoftwareDecode: false,
			expectComplete:       true,
		},
		{
			name:                 "VP9_10bit_Profile2",
			file:                 "test_vp9_10bit.webm",
			preset:               "compress-hevc",
			expectSoftwareDecode: false,
			expectComplete:       true,
		},

		// === MPEG-4 Tests ===
		{
			name:                 "MPEG4_Simple_MayHardwareDecode",
			file:                 "test_mpeg4_simple.avi",
			preset:               "compress-hevc",
			expectSoftwareDecode: false,
			// MPEG4 can transcode successfully - just verify it processes without crashing
			expectComplete: true,
		},

		// === AV1 Tests ===
		{
			name:       "AV1_8bit_TranscodeToHEVC",
			file:       "test_av1_8bit.mkv",
			preset:     "compress-hevc",
			expectSkip: false, // AV1 -> HEVC should attempt transcode
			// Note: AV1 is more efficient than HEVC, so output may be larger
			expectComplete: false,
			expectFail:     true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Check if file exists
			srcPath := filepath.Join(testdataDir, tt.file)
			if _, err := os.Stat(srcPath); os.IsNotExist(err) {
				t.Skipf("test file not found: %s", tt.file)
			}

			runCodecDetectionTest(t, testdataDir, tt.file, tt.preset,
				tt.expectSoftwareDecode, tt.expectSkip, tt.expectComplete, tt.expectFail)
		})
	}
}

func runCodecDetectionTest(t *testing.T, testdataDir, filename, presetID string,
	expectSoftwareDecode, expectSkip, expectComplete, expectFail bool) {

	// Create temp directory for this test
	tmpDir := t.TempDir()

	// Copy test file to temp dir
	srcPath := filepath.Join(testdataDir, filename)
	dstPath := filepath.Join(tmpDir, filename)
	if err := copyTestFile(srcPath, dstPath); err != nil {
		t.Fatalf("failed to copy test file: %v", err)
	}

	// Setup config
	cfg := &config.Config{
		MediaPath:        tmpDir,
		TempPath:         tmpDir,
		FFmpegPath:       "ffmpeg",
		FFprobePath:      "ffprobe",
		Workers:          1,
		OriginalHandling: "keep",
		OutputFormat:     "mkv",
	}

	// Create in-memory queue (no store to avoid import cycle)
	queue := NewQueue()

	// Probe the file
	prober := ffmpeg.NewProber(cfg.FFprobePath)
	probe, err := prober.Probe(context.Background(), dstPath)
	if err != nil {
		t.Fatalf("failed to probe file: %v", err)
	}

	// Log probe results for debugging
	t.Logf("Probe: codec=%s profile=%s bit_depth=%d pix_fmt=%s size=%d",
		probe.VideoCodec, probe.Profile, probe.BitDepth, probe.PixelFormat, probe.Size)

	// Check proactive detection
	preset := ffmpeg.GetPreset(presetID)
	if preset == nil {
		t.Fatalf("unknown preset: %s", presetID)
	}

	// Note: RequiresSoftwareDecode returns false for software encoders (HWAccelNone)
	// because software encoding doesn't need hardware decode fallback.
	// Test with a hypothetical hardware encoder to verify the detection logic.
	requiresSoftwareForHW := ffmpeg.RequiresSoftwareDecode(
		probe.VideoCodec, probe.Profile, probe.BitDepth, ffmpeg.HWAccelQSV)

	if requiresSoftwareForHW != expectSoftwareDecode {
		t.Errorf("RequiresSoftwareDecode(%q, %q, %d, QSV) = %v, want %v",
			probe.VideoCodec, probe.Profile, probe.BitDepth,
			requiresSoftwareForHW, expectSoftwareDecode)
	}

	if requiresSoftwareForHW {
		t.Logf("PROACTIVE DETECTION: File would require software decode on hardware encoder (codec=%s, profile=%s, bit_depth=%d)",
			probe.VideoCodec, probe.Profile, probe.BitDepth)
	}

	// Add job to queue
	job, err := queue.Add(dstPath, presetID, probe, "")
	if err != nil {
		t.Fatalf("failed to add job: %v", err)
	}

	// Check for skip - jobs are created but immediately skipped with skip message
	if expectSkip {
		if job.Status == StatusSkipped {
			if strings.Contains(job.Error, "already") ||
				strings.Contains(job.Error, "HEVC") ||
				strings.Contains(job.Error, "AV1") {
				t.Logf("File correctly skipped: %s", job.Error)
				return
			}
		}
		t.Errorf("expected file to be skipped, but job was created with status %s: %s", job.Status, job.Error)
		return
	}

	t.Logf("Job created: %s", job.ID)

	// Subscribe to events
	events := queue.Subscribe()
	defer queue.Unsubscribe(events)

	// Create worker pool and process
	pool := NewWorkerPool(queue, cfg, nil)
	pool.Start()
	defer pool.Stop()

	// Wait for job completion with timeout
	timeout := time.After(5 * time.Minute)
	var finalJob *Job

	for {
		select {
		case event := <-events:
			if event.Job.ID != job.ID {
				continue
			}

			t.Logf("Event: %s (progress: %.1f%%, speed: %.2fx)",
				event.Type, event.Job.Progress, event.Job.Speed)

			if event.Type == "complete" || event.Type == "failed" || event.Type == "cancelled" {
				finalJob = event.Job
				goto done
			}

		case <-timeout:
			t.Fatalf("timeout waiting for job completion")
		}
	}

done:
	t.Logf("Job finished: status=%s error=%q", finalJob.Status, finalJob.Error)

	// Verify expectations
	if expectComplete {
		if finalJob.Status != StatusComplete {
			t.Errorf("expected status=complete, got %s: %s", finalJob.Status, finalJob.Error)
		}

		// Verify output exists and is valid
		if finalJob.OutputPath != "" {
			outProbe, err := prober.Probe(context.Background(), finalJob.OutputPath)
			if err != nil {
				t.Errorf("failed to probe output: %v", err)
			} else {
				t.Logf("Output: codec=%s size=%d (saved %d bytes, %.1f%%)",
					outProbe.VideoCodec, outProbe.Size, finalJob.SpaceSaved,
					float64(finalJob.SpaceSaved)/float64(finalJob.InputSize)*100)

				// Verify output is HEVC (for HEVC presets)
				if preset.Codec == ffmpeg.CodecHEVC && outProbe.VideoCodec != "hevc" {
					t.Errorf("expected output codec=hevc, got %s", outProbe.VideoCodec)
				}
			}
		}
	}

	if expectFail {
		if finalJob.Status != StatusFailed {
			t.Errorf("expected status=failed, got %s", finalJob.Status)
		}
		t.Logf("Job correctly failed: %s", finalJob.Error)
	}
}

func copyTestFile(src, dst string) error {
	input, err := os.ReadFile(src)
	if err != nil {
		return fmt.Errorf("read %s: %w", src, err)
	}
	if err := os.WriteFile(dst, input, 0644); err != nil {
		return fmt.Errorf("write %s: %w", dst, err)
	}
	return nil
}

// TestRequiresSoftwareDecodeProactive verifies the proactive detection function
// correctly identifies all known hardware decode limitations.
func TestRequiresSoftwareDecodeProactive(t *testing.T) {
	tests := []struct {
		name     string
		codec    string
		profile  string
		bitDepth int
		encoder  ffmpeg.HWAccel
		expected bool
	}{
		// === H.264 10-bit ===
		// NVENC: Let FFmpeg try HW decode (RTX 50 supports 4:2:2 10-bit)
		// Others: Proactively use software decode
		{"H264_10bit_QSV", "h264", "High 10", 10, ffmpeg.HWAccelQSV, true},
		{"H264_10bit_VAAPI", "h264", "High 10", 10, ffmpeg.HWAccelVAAPI, true},
		{"H264_10bit_NVENC", "h264", "High 10", 10, ffmpeg.HWAccelNVENC, false}, // Let NVENC try
		{"H264_10bit_VideoToolbox", "h264", "High 10", 10, ffmpeg.HWAccelVideoToolbox, true},
		{"AVC_10bit_QSV", "avc", "High 10", 10, ffmpeg.HWAccelQSV, true},

		// === H.264 8-bit - Hardware decode supported ===
		{"H264_8bit_QSV", "h264", "High", 8, ffmpeg.HWAccelQSV, false},
		{"H264_8bit_VAAPI", "h264", "High", 8, ffmpeg.HWAccelVAAPI, false},
		{"H264_8bit_NVENC", "h264", "High", 8, ffmpeg.HWAccelNVENC, false},
		{"H264_8bit_VideoToolbox", "h264", "High", 8, ffmpeg.HWAccelVideoToolbox, false},

		// === HEVC - All bit depths hardware supported ===
		{"HEVC_8bit_QSV", "hevc", "Main", 8, ffmpeg.HWAccelQSV, false},
		{"HEVC_10bit_QSV", "hevc", "Main 10", 10, ffmpeg.HWAccelQSV, false},
		{"HEVC_8bit_VAAPI", "hevc", "Main", 8, ffmpeg.HWAccelVAAPI, false},
		{"HEVC_10bit_VAAPI", "hevc", "Main 10", 10, ffmpeg.HWAccelVAAPI, false},

		// === VC-1/WMV - Spotty support ===
		{"VC1_QSV", "vc1", "", 8, ffmpeg.HWAccelQSV, true},
		{"VC1_VAAPI", "vc1", "", 8, ffmpeg.HWAccelVAAPI, true},
		{"VC1_NVENC", "vc1", "", 8, ffmpeg.HWAccelNVENC, true},
		{"WMV3_QSV", "wmv3", "", 8, ffmpeg.HWAccelQSV, true},
		{"WMV3_VAAPI", "wmv3", "", 8, ffmpeg.HWAccelVAAPI, true},

		// === MPEG-4 ===
		{"MPEG4_ASP_QSV", "mpeg4", "Advanced Simple", 8, ffmpeg.HWAccelQSV, true},
		{"MPEG4_Simple_QSV", "mpeg4", "Simple", 8, ffmpeg.HWAccelQSV, false},
		{"MPEG4_Simple_VAAPI", "mpeg4", "Simple", 8, ffmpeg.HWAccelVAAPI, false},

		// === Software encoder - No fallback needed ===
		{"H264_10bit_Software", "h264", "High 10", 10, ffmpeg.HWAccelNone, false},
		{"VC1_Software", "vc1", "", 8, ffmpeg.HWAccelNone, false},

		// === Case insensitivity ===
		{"H264_10bit_Lowercase", "H264", "high 10", 10, ffmpeg.HWAccelQSV, true},
		{"AVC_Mixed", "AVC", "HIGH 10", 10, ffmpeg.HWAccelVAAPI, true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := ffmpeg.RequiresSoftwareDecode(tt.codec, tt.profile, tt.bitDepth, tt.encoder)
			if result != tt.expected {
				t.Errorf("RequiresSoftwareDecode(%q, %q, %d, %v) = %v, want %v",
					tt.codec, tt.profile, tt.bitDepth, tt.encoder, result, tt.expected)
			}
		})
	}
}

// TestEncoderFallbackChainIntegrity verifies the fallback chain is properly configured
func TestEncoderFallbackChainIntegrity(t *testing.T) {
	// Verify the fallback chain is properly configured and terminates correctly

	codecs := []ffmpeg.Codec{ffmpeg.CodecHEVC, ffmpeg.CodecAV1}
	hwEncoders := []ffmpeg.HWAccel{
		ffmpeg.HWAccelVideoToolbox,
		ffmpeg.HWAccelNVENC,
		ffmpeg.HWAccelQSV,
		ffmpeg.HWAccelVAAPI,
	}

	for _, codec := range codecs {
		for _, startEncoder := range hwEncoders {
			name := fmt.Sprintf("%s_%s", startEncoder, codec)
			t.Run(name, func(t *testing.T) {
				// Walk the entire fallback chain
				current := startEncoder
				seen := make(map[ffmpeg.HWAccel]bool)
				steps := 0
				maxSteps := 10

				for steps < maxSteps {
					if seen[current] {
						t.Fatalf("Cycle detected at %v after %d steps", current, steps)
					}
					seen[current] = true

					if current == ffmpeg.HWAccelNone {
						// Successfully reached software - chain is valid
						return
					}

					fallback := ffmpeg.GetFallbackEncoder(current, codec)
					if fallback == nil {
						// Chain ended - verify software wasn't available
						swEnc := ffmpeg.GetEncoderByKey(ffmpeg.HWAccelNone, codec)
						if swEnc != nil && swEnc.Available {
							t.Errorf("Chain ended at %v but software is available", current)
						}
						return
					}

					// Verify fallback is lower priority
					if fallback.Accel == current {
						t.Fatalf("Fallback returned same encoder %v", current)
					}

					current = fallback.Accel
					steps++
				}

				t.Errorf("Chain exceeded %d steps without terminating", maxSteps)
			})
		}
	}
}

// TestFallbackTriggersForSoftwareDecodeStart verifies encoder fallback works when starting with SW decode
func TestFallbackTriggersForSoftwareDecodeStart(t *testing.T) {
	// Verify that encoder fallback logic works even when we start with SW decode
	// This is the critical case that was previously broken (Issue #77)

	// The key insight: shouldRetryWithSoftwareDecode returns false for HWAccelNone,
	// so software encoder won't try SW decode retry (it's already SW everything).
	// But GetFallbackEncoder(HWAccelNone, codec) returns nil, so we don't loop forever.

	// Test that software encoder correctly returns no fallback
	for _, codec := range []ffmpeg.Codec{ffmpeg.CodecHEVC, ffmpeg.CodecAV1} {
		fallback := ffmpeg.GetFallbackEncoder(ffmpeg.HWAccelNone, codec)
		if fallback != nil {
			t.Errorf("GetFallbackEncoder(HWAccelNone, %v) = %v, want nil", codec, fallback.Accel)
		}
	}

	// Test that hardware encoders always have a fallback path
	for _, encoder := range []ffmpeg.HWAccel{ffmpeg.HWAccelQSV, ffmpeg.HWAccelVAAPI, ffmpeg.HWAccelNVENC} {
		fallback := ffmpeg.GetFallbackEncoder(encoder, ffmpeg.CodecHEVC)
		// Should either return a fallback or be unavailable on this system
		// The key is it shouldn't panic or loop
		if fallback != nil && fallback.Accel == encoder {
			t.Errorf("GetFallbackEncoder(%v) returned same encoder", encoder)
		}
	}
}

// TestShouldRetryWithSoftwareDecode verifies the retry decision logic
func TestShouldRetryWithSoftwareDecode(t *testing.T) {
	tests := []struct {
		name     string
		encoder  ffmpeg.HWAccel
		expected bool
	}{
		// Hardware encoders should trigger retry
		{"QSV", ffmpeg.HWAccelQSV, true},
		{"VAAPI", ffmpeg.HWAccelVAAPI, true},
		{"NVENC", ffmpeg.HWAccelNVENC, true},
		{"VideoToolbox", ffmpeg.HWAccelVideoToolbox, true},

		// Software encoder should NOT trigger retry (no hardware to fall back from)
		{"Software", ffmpeg.HWAccelNone, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := shouldRetryWithSoftwareDecode(tt.encoder)
			if result != tt.expected {
				t.Errorf("shouldRetryWithSoftwareDecode(%v) = %v, want %v",
					tt.encoder, result, tt.expected)
			}
		})
	}
}
